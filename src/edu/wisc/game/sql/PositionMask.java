package edu.wisc.game.sql;

import java.io.*;
import java.util.*;

import edu.wisc.game.util.*;
//import edu.wisc.game.parser.*;
import edu.wisc.game.engine.*;

/** An auxiliary data structure describing optional restrictions on
    the positions of game pieces on the initial boards generated by
    the random board generator */

class PositionMask {

    /** This is set to true by setConditions if the condRules parameter
	is supplied and can be interpreted as some kind of position mask.
     */
    boolean hasPositionMask = false;

    /** May be used in training stage when position mask is in effect.*/
    int[] allPiecesMustBeHere = null;
    /** May be used in testing stage when position mask is in effect.*/
    int[] atLeastOnePieceMustBeHere = null;
    /** Same as the above, as a set */
    HashSet<Integer> atLeastOnePieceMustBeHereHash = null;

    
    /** For the training/testing restrictions on boards, as introduced in GS 6.010. See email discusion with Paul on 2023-03-08, and captive.html#cond
     */
    PositionMask(boolean testing, RuleSet condRules) {
	hasPositionMask = condRules.isPositionMask();

	if (!hasPositionMask) return;
	Vector<Integer> v = new Vector<>();
	for(int j=1; j<= Board.N*Board.N; j++) {
	    if ( BoardConditionsChecker.positionIsAllowed(j, condRules, testing)) {
		v.add(j);
	    }
	}
	int[] w = new int[v.size()];
	for(int i=0;i<w.length; i++) w[i] = v.get(i);
	
	if (testing) {
	    atLeastOnePieceMustBeHere = w;
	    atLeastOnePieceMustBeHereHash = new HashSet<>();
	    for(int j: atLeastOnePieceMustBeHere) atLeastOnePieceMustBeHereHash.add(j);
	} else { // training
	    allPiecesMustBeHere = w;
	}
    }

    public String toString() {
	String s = "PositionMask(";
	if (allPiecesMustBeHere != null) {
	    s += "allPiecesMustBeHere=["+Util.joinNonBlank(",", allPiecesMustBeHere )+"]";
	}
	if (atLeastOnePieceMustBeHere!= null) {
	    s += "atLeastOnePieceMustBeHere=["+Util.joinNonBlank(",", atLeastOnePieceMustBeHere )+"]";
	}
	s += ")";
	return s;
    }
    	    	    
}
