package edu.wisc.game.parser;

import java.io.*;
import java.util.*;
import java.text.*;

interface Expression {

    static class ExList extends Vector<Expression> implements Expression {
	ExList( Vector<Expression> v) {
	    super(v);
	}
	public String toString(char open, char close) {
	    Vector<String> v = new Vector<>();
	    for(Expression e: this) v.add(e.toString());
	    return ""+ open + String.join(", ", v) + close;
	}

    };

    static public class ParenList extends ExList {
 	ParenList( Vector<Expression> v) {
	    super(v);
	}
	public String toString() {
	    return toString('(', ')');
	}
    };
    static public class BracketList extends ExList {
 	BracketList( Vector<Expression> v) {
	    super(v);
	}
	public String toString() {
	    return toString('[', ']');
	}
    };

    //static interface  ArithmeticExpression extends Expression;
    
    abstract static class  ArithmeticExpression extends Vector<ArithmeticExpression>  implements Expression {
	ArithmeticExpression() { super(); }
	Vector<Token> ops = new Vector<>() ;
	
	abstract Integer eval(HashMap<String, Integer> h);       

	public String toString() {
	    Vector<String> v = new Vector<>();
	    v.add(firstElement().toString());
	    for(int j=0; j<ops.size(); j++) {
		v.add(ops.get(j).toString());
		v.add(get(j+1).toString());
	    }
	    return "{"+ String.join(" ", v) + "}";
	}

    }

    public static class AdditiveExpression extends  ArithmeticExpression  {

	AdditiveExpression() {}
	AdditiveExpression(ArithmeticExpression x) {
	    add(x);
	}

	/** Wraps a given expression into an AdditiveExpression if needed */
	private static AdditiveExpression asAddi(ArithmeticExpression ex)  {
	    return (ex instanceof AdditiveExpression)?
		(AdditiveExpression)ex :
		new  AdditiveExpression(ex);
	}
	

	/** Checks if a given expression (which is assumed to be a HAE) is
	    followed by one or more additive terms, and puts 
	    them together in one Additive expression */
	ArithmeticExpression expandAsAddi(ArithmeticExpression x, Vector<Token> tokens) throws ParseException {

	    while(tokens.size()>0 && tokens.firstElement().type==Token.Type.ADD_OP){
		AdditiveExpression y = asMulti(x);
		x = y;
		y.ops.add(tokens.remove(0));

		if (tokens.isEmpty()) throw new  ParseException("Unexpected end of additive expression");
		ArithmeticExpression b = mkHAE(tokens);
		y.add(b);
	    }
	    return x;
	}


	Integer eval(HashMap<String, Integer> h) {
	    Integer s = firstElement().eval(h);
	    if (s==null) return null;
	    for(int j=1; j<size(); j++) {
		Integer q =get(j).eval(h);
		if (q==null) return null;
		Token op = ops.get(j-1);
		if (op.cVal == '+') s += q;
		else if (op.cVal == '-') s -= q;
		else throw new IllegalArgumentException("Illegal operation " + op + " in an additive expression");
	    }
	    return s;
	}

    }

    public static class Num extends  ArithmeticExpression {
	final public int nVal;
	Num(Token t) throws ParseException {
	    if (t.type!=Token.Type.NUMBER) throw new  ParseExpression("Not a number");
	    nVal = t.nVal;
	}
	Integer eval(HashMap<String, Integer> h) {
	    return nVal;
	}
	public String toString() {
	    return "" + nVal;
	}
    }

    public static class Id extends ArithmeticExpression  
    {
	final public String sVal;
	Id(Token t) throws ParseException {
	    if (t.type!=Token.Type.ID) throw new  ParseExpression("Not an id");
	    sVal = t.sVal;
	}
	Integer eval(HashMap<String, Integer> h) {
	    return h.get(sVal);
	}
	public String toString() {
	    return sVal;
	}
    }
    
    public static class MultiplicativeExpression extends  ArithmeticExpression  {
	MultiplicativeExpression() {	}

	MultiplicativeExpression(ArithmeticExpression x) {
	    add(x);
	}

	/** Wraps a given expression into a MultiplicativeExpression if needed */
	private static MultiplicativeExpression asMulti(ArithmeticExpression ex)  {
	    return (ex instanceof MultiplicativeExpression)?
		(MultiplicativeExpression)ex :
		new  MultiplicativeExpression(ex);
	}
	

	/** Checks if a given expression (which is assumed to be a HAE) is
	    followed by one or more multiplicative terms, and puts 
	    them together in one Multiplicative expression */
	static ArithmeticExpression expandAsMulti(ArithmeticExpression x, Vector<Token> tokens) throws ParseException {
	    while(tokens.size()>0 && tokens.firstElement().type==Token.Type.MULT_OP) {
		MultiplicativeExpression y = asMulti(x);
		x = y;
		y.ops.add(tokens.remove(0));
		ArithmeticExpression b = getFirstHAE(tokens);
		y.add(b);
	    }
	    return x;
	}

	
	/** Expands this MultiplicativeExpression from tokens */
	/*
	void expand(Vector<Token> tokens) throws ParseException {
	    while(tokens.size()>0 && tokens.firstElement().type==Token.Type.MULT_OP) {
		ops.add(tokens.remove(0));
		ArithmeticExpression b = getFirstHAE(tokens);
		add(b);
	    }
	}
	*/
	
	Integer eval(HashMap<String, Integer> h) {	  	    
	    Integer s = firstElement().eval(h);
	    if (s==null) return null;
	    for(int j=1; j<size(); j++) {
		Integer q =get(j).eval(h);
		if (q==null) return null;
		Token op = ops.get(j-1);
		int r = q.intValue();
		if (op.cVal == '*') s *= r;
		else if (op.cVal == '/') s /= r;
		else if (op.cVal == '%') s %= r;
		else throw new IllegalArgumentException("Illegal operation " + op + " in a multiplicative expression");
	    }
	    return s;
	}
	
    }

    static class Star  implements Expression {	};
    
    static Expression mkExpression(Vector<Token> tokens) throws ParseException {
	if (tokens.size()==0) throw new ParseException("Unexpected end of expression");
	Token a = tokens.firstElement();

	if (a.type==Token.Type.MULT_OP && a.cVal=='*') {
	    tokens.remove(0);
	    return new Star();
	} else if (a.type==Token.Type.OPEN) {
	    Token open = a;
	    tokens.remove(0);
	    Vector<Expression> v = new Vector<>();
	    while(tokens.size()>0) {
		Expression z = mkExpression(tokens);
		v.add(z);
		if (tokens.size()==0) throw new  ParseException("Unexpected end of expression");
		Token b = tokens.firstElement();
		if (b.type==Token.Type.COMMA) {
		    tokens.remove(0);
		    continue;
		} else 	if (b.type==Token.Type.CLOSE) {
		    tokens.remove(0);
		    if (open.cVal=='(' && b.cVal==')') {
			if (v.size()==1 && v.get(0) instanceof ArithmeticExpression) {
			    return mkArithmeticExpression(tokens, (ArithmeticExpression)v.get(0));
			} else {
			    return new ParenList(v);
			}			    
		    } else if (open.cVal=='[' && b.cVal==']') {
			return new ParenList(v);
		    } else {
			throw new ParseException("Paren/bracket mismatch: " + open.cVal + "..." + b.cVal);
		    }
		}
	    }
	    throw new  ParseException("Missing closing paren/bracket: no match for " + open);
	} else {
	    return mkArithmeticExpression(tokens);
	}	
    }

    private static ArithmeticExpression mkArithmeticExpression(Vector<Token> tokens) throws ParseException {
	ArithmeticExpression a = mkHAE(tokens);
	return mkArithmeticExpression(tokens, a);
    }


    private static ArithmeticExpression mkArithmeticExpression(Vector<Token> tokens, ArithmeticExpression firstHAE) throws ParseException {

	ArithmeticExpression w = MultiplicativeExpression.expandAsMulti(firstHAE, tokens);	// (firstHAE) * x
	return AdditiveExpression.expandAsAddi(w, tokens);
    }

    
    private static ArithmeticExpression mkHAE(Vector<Token> tokens) throws ParseException {
	ArithmeticExpression a = getFirstHAE(tokens);
	return MultiplicativeExpression.expandAsMulti(a, tokens);
    }


	
    private static ArithmeticExpression getFirstHAE(Vector<Token> tokens) throws ParseException {
	if (tokens.size()==0) throw new ParseException("Unexpected end of expression");
	Token a = tokens.firstElement();
	Vector<Expression> v = new Vector<>();
	if (a.type == Token.Type.ID) {
	    tokens.remove(0);
	    return new Id(a);
	} else if (a.type == Token.Type.NUMBER) {
	    tokens.remove(0);
	    return new Num(a);
	} else if (a.type==Token.Type.OPEN && a.cVal=='(') {
	    Expression parList = mkExpression(tokens);
	    if (parList instanceof ArithmeticExpression) {
		return (ArithmeticExpression)parList;
	    } else if ((parList instanceof  ParenList) && ((ParenList)parList).size()==1) {
		Expression ex =  ((ParenList)parList).get(0);
		if (ex instanceof  ArithmeticExpression) {
		    return  (ArithmeticExpression)ex;
		} else {
		    throw new ParseException("Expected arithmetic expression, found: " + ex);
		}
	    } else {
		throw new ParseException("Expected (arithmetic), found: " +
					 parList.getClass() + ": " +
					 parList);
	    }
	} else {
	    throw new ParseException("Expected primitive or (arithmetic), but not found it");
	}
    }
    

}
