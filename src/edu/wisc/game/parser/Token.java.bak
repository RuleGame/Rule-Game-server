package edu.wisc.game.parser;

import java.io.*;
import java.util.*;
import java.text.*;

class Token {

    
    enum Type { NUMBER, ID, COMMA, MULT_OP, ADD_OP, OPEN, CLOSE};
    final Type type;
    char cVal=0;
    String sVal=null;
    int nVal=0;

    public String toString() {
	String s = "" + type + ".";
	if (type == Type.NUMBER) s += nVal;
	else if (type == Type.ID) s += sVal;
	else s += cVal;
	return s;
    }

    /** Init based on the first character */
    private Token(char c) throws ParseException {
	type =
	    Character.isDigit(c)? Type.NUMBER:
	    Character.isJavaIdentifierStart(c)? Type.ID:
	    c==','? Type.COMMA:
	    c=='+' || c=='-'? Type.ADD_OP:
	    c=='*' || c=='/' || c=='%' ? Type.MULT_OP:
	    c=='(' || c=='['? Type.OPEN:
	    c==')' || c==']'? Type.CLOSE:
	    null;
	if (type==null) throw new ParseException("Illegal character: " + c);
	cVal=c;
	sVal="" + c;
    }
    /** Sets other fields based on type and sVal */
    private void complete() {
	if (type==Type.NUMBER) {
	    nVal = Integer.parseInt(sVal);
	    cVal=0;
	} else if (type==Type.ID) {
	    cVal=0;
	} else {
	    cVal=sVal.charAt(0);
	}
    }

    
    //--- Used by the tokenizer
    static class Tokenizer {
	final Vector<Token> result = new Vector<>();

	private Token currentToken=null;

	Tokenizer(String x) throws ParseException {
	    for(int i=0; i<x.length(); i++) {
		addC(x.charAt(i));
	    }
	    flush();
	}
	
	private  void  flush() {
	    if (currentToken==null) return;	
	    currentToken.complete();
	    result.add(currentToken);
	    currentToken = null;	
	}

	private void  addC(char c) throws ParseException {
	    if (currentToken!=null) {
		if (Character.isDigit(c) && currentToken.type==Type.NUMBER ||
		    Character.isJavaIdentifierPart(c) && currentToken.type==Type.ID) {
		    currentToken.sVal += c;
		    return;
		} else {
		    flush();
		}
	    }
	    if (Character.isWhitespace(c)) {
		flush();
		return;
	    }
	    currentToken= new Token(c);	
	}
    }
	
    public static Vector<Token> tokenize(String x) throws ParseException {
	Tokenizer t = new Tokenizer(x);
	return t.result;
	//return (Token[])t.result.toArray(new Token[0]);
    }

    static public String toString(Vector<Token> tokens) {
	Vector<String> v = new Vector<>();
	for(Token t: tokens) {
	    v.add(t.toString());
	}
	return String.join(" ", v);
   }

    public static void main(String[] argv) throws IOException,  ParseException {

	HashMap<String, Integer> h = new HashMap<>();
	h.put("one", 1);
	h.put("two", 2);
    	h.put("three", 3);
	h.put("four", 4);

	InputStream in = System.in;
	LineNumberReader reader = new LineNumberReader(new InputStreamReader(System.in));
	String s;
	while((s=reader.readLine())!=null) {
	    Vector<Token> q= tokenize(s);
	    System.out.println(toString(q));

	    try {
		Expression ex = Expression.mkExpression(q);
		
		System.out.println("E=" + ex);
		
		if (ex instanceof Expression.ArithmeticExpression) {
		    Expression.ArithmeticExpression ae = (Expression.ArithmeticExpression)ex;
		    
		    System.out.println("Eval=" + ae.eval(h));
		}
	    } catch(ParseException ex) {
		System.err.println(ex);
		ex.printStackTrace(System.err);
	    }
 	    
	}
    }

      
    
}
